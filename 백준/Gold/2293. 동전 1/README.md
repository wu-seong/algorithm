# [Gold V] 동전 1 - 2293 

[문제 링크](https://www.acmicpc.net/problem/2293) 

### 성능 요약

메모리: 31120 KB, 시간: 320 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 3월 19일 13:37:06

### 문제 설명

<p>n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.</p>

<p>사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.</p>

### 입력 

 <p>첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.</p>

### 출력 

 <p>첫째 줄에 경우의 수를 출력한다. 경우의 수는 2<sup>31</sup>보다 작다.</p>


 ------
 ## 문제 풀이

 ### 문제 접근

단순히 1차원적으로 생각하여 dp[n] = dp[n-1]~~ 이런식으로 점화식을 세워서 풀려고 했다.
(n은 구하려는 k이하의 수이다.)
처음 세웠던 점화식은 단순하게 n은 dp[n] = dp[n-1]*dp[1] + dp[n-2]*dp[2] + ... + dp[1]*dp[n-1] 으로 잠시 생각했다가 대충 생각해봐도 너무 많은 경우가 생기고 겹치는 부분이 많아서 다시 생각을 해봤다.

먼저 코인의 value에 따라 유무를 0 1 로 배열에 저장시켜두고
다음 점화식은 이렇게 세웠다. dp[n] = dp[n-1]*existValue(1) + dp[n-2]*existValue(2)+ ... + dp[1]*existValue(n-1) 그러나 이 역시도 겹치는 부분이 많이 생겼다.
아무리 머리를 굴려도 점화식이 생각나지 않아서 풀이를 봤다.

 ### 유의할 점
복잡한 경우의 수 같은 문제는 머리로만 풀려고 하기 보다는 낮은 경우부터 직접 손으로써서 생각해보는 것이 좋다.

 ### 개선할 점
dp라고 해서 단순히 1차원적인 점화식을 세워서 구할 수 있는 것이 아니다. 지금 문제와 같이 하나의 목표 가치 합에 대해서 여러가지 동전을 사용할 수 있는 복잡한 문제의 경우
2차원 적으로 생각을 하여 관점을 다르게 하여 쉬운 조건에 대해서 먼저 결과를 구한 뒤 이를 사용하여 2차원적으로 점화식을 세워서 구할 수도 있다.  
 

