'''
한 명이라도 나보다 둘 다 높은 것이 있으면 나는 탈락
모두 모든 것을 다 비교하기엔 시간복잡도가 높음
가장 높은 것만 찾으면 될 것 같긴한데
나보다 A가 큰 것중 B가 가장 큰 것이 나의 B보다 크면 나는 탈락
나보다 A가 큰 것을 구하려면? 
A를 기준으로 정렬을 했으면 바로 구할 순 있음
근데 그 중 가장 큰 B를 구하기 위해선 힙을 이용해야하는데
A에서의 각 연속 집합마다 힙을 구할 순 없음

A에서 가장 큰 것을 기준해서 천천히 힙을 만들어 나가면 어떰?
A에서 첫 a보다 큰 것은 없으니 빈 힙으로 시작
본인의 b값을 추가
1. heap[0]의 값을 비교
2-1. 만약 나의 b값보다 크다면 탈락 -> b값이 커도 a가 같을 수도 있음
a값이 변하지 않을때는 모아뒀다가 한번에 push하기
2-2. 나의 b값보다 작거나 같다면 나의 b값도 heappush
...
heap에는 탈락하지 않은 사원만이 남게된다.
해당 heap을 다시 두 합을 기준으로 내림차순 정렬하여 0번째 사원의 순위를 찾기.
기본적으로는 인덱스+1이지만 만약 앞의 값이 0번째 사원과 같으면 다를 때 까지 앞 인덱스를 본인의 인덱스로 취급

--> heap으로 하는 것이 아니라 내림차순-오름차순 순으로 정렬해서
둘 모두 이전에 나왔던 사원보다 작은 값인지를 판단해야함
ex) 10 12, 10 13, 9 11, 9 13 이면
a, b모두가 나보다 커야 함
근데 a는 내림차순이기 때문에 내 앞 것이 같거나 크다.
b는 오름차순이기 때문에 같은 a값에 대해선 탈락할 일이 없다.
따라서 이전에 나온 a와 b 값이 둘다 크기 위해선
b의 값에 집중하여 현재 b의 값이 만약 이전의 b값보다 작다면(같은 a에 대해선 오름차순인데 작다는 건 a가 일단 더 작다는 것임) 탈락하는 것임
'''

def solution(scores):
    n = len(scores)
    rank = 0
    target = scores[0]
    target_sum = target[0] + target[1]
    scores.sort(key=lambda x: (-x[0], x[1]))
    #print(scores)
    pre_b = scores[0][1]
    for i in range(n):
        a, b = scores[i]
        if a > target[0] and b > target[1]:
            return -1
        if a + b <= target_sum:
            continue
        if b >= pre_b:
            pre_b = b
            rank += 1
    print(rank)
    return rank + 1