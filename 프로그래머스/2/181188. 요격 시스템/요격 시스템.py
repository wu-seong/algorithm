def solution(targets):
    '''
    미사일을 하나씩 추가하면서 요격해야할 범위를 좁히거나 새로운 요격 미사일을 추가한다?
    
    4,5 -> (4,5)
    4,8 -> 4,8이 4,5 요격 범위를 포함하고 있다. -> (4,5)
    10,14 -> 요격 범위를 완전히 벗어난다. -> (10,14) 추가 -> (4,5), (10,14)
    11,13 -> 요격 범위 안에 포함된다. -> (10,14)를 줄임 -> (4,5), (11,13)
    5,12 -> 요격 범위 안에 포함된다. -> (4,5), (11,12)
    3,7 -> 요격 범위를 포함하고 있다. -> (4,5), (11,12)
    1,4 -> 요격 범위를 완전히 벗어난다. -> (1,4), (4,5), (11,12)
    
    -> 새로운 미사일의 범위를 각 요격 범위와 비교
    -> 새로운 미사일이 어떤 요격 범위를 완전히 포함하고 있으면 그대로 
    a,e
    a < start and e > end
    -> 새로운 미사일이 어떤 요격 범위에도 포함되어있지 않으면 새로운 요격 추가 및 카운팅
    e <= start or a >= end
    -> 새로운 미사일이 어떤 요격 범위에 일부만 포함되어 있다면 요격 범위를 줄이기 (교집합으로)
    (start < e < end) -> end = e (start < a < end) start = a
    
    ... 새로운 미사일이 여러 요격 범위에 걸쳐있다면 어떤 것을 선택할지 정하기가 어렵다.
    
    다른 방법
    
    target을 합치기 
    어떤 target이든 범위에 조금이라도 포함되면
    끝 범위를 기준으로 정렬
    이렇게 정렬하면 앞으로 추가될 미사일이  (1,3) (4,6)  [2,5]
    
    중간에 걸치는 경우 앞으로 요격되는 것을 선택, 앞의 start범위가 줄어도 이후에 올 미사일에 타격이 없음
    
    -> 이렇게 하면 앞으로 들어올 미사일은 시작점이 끝점보다 크지 않다면 항상 요격 가능함
    
    (1,4), (4,5), (3,7), (4,8), (5,12), (11,13)
    1,4 -> (1,4)
    4,5 -> (1,4) (4,5)
    3,7 -> (3,4), (4,5)
    4,8 -> (1,4), (4,5)
    5,12 -> (1,4), (4,5) (5,12)
    11,13 -> (1,4), (4,5), (11,12)
    '''
    targets.sort(key=lambda x: x[1])
    #print(targets)
    
    end = -1
    cnt = 0
    for target in targets:
        a,e = target
        if end <= a: # 새로운 미사일이 요격 범위 밖이라면
            end = e
            cnt += 1
    print(cnt)
    return cnt